<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trascrizione e Analisi Audio Avanzata</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <style>
        /* RESET & BASE */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            color: #667eea;
            text-align: center;
            margin-bottom: 10px;
            font-size: 28px;
        }
        .subtitle {
            text-align: center;
            color: #6b7280;
            margin-bottom: 30px;
            font-size: 14px;
        }

        /* TABS */
        .tabs { 
            display: flex; 
            gap: 10px; 
            margin-bottom: 30px; 
            border-bottom: 2px solid #e5e7eb; 
            flex-wrap: wrap; 
        }
        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            color: #6b7280;
            transition: all 0.3s;
        }
        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        /* INFO BOX */
        .info-box {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .info-box ol {
            color: inherit;
        }
        .info-box ol li {
            margin: 5px 0;
        }

        /* UPLOAD */
        .upload-area {
            border: 3px dashed #d1d5db;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .upload-area:hover {
            border-color: #667eea;
            background: #f9fafb;
        }
        .upload-area.dragover {
            border-color: #667eea;
            background: #eef2ff;
        }
        .upload-icon { font-size: 48px; margin-bottom: 10px; }

        /* SPEAKER COLORS */
        .speaker-1 { 
            background: linear-gradient(90deg, #3b82f6, #2563eb);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 12px;
        }
        .speaker-2 { 
            background: linear-gradient(90deg, #10b981, #059669);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 12px;
        }
        .speaker-3 { 
            background: linear-gradient(90deg, #f59e0b, #d97706);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 12px;
        }
        .speaker-4 { 
            background: linear-gradient(90deg, #ef4444, #dc2626);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 12px;
        }
        .speaker-5 { 
            background: linear-gradient(90deg, #8b5cf6, #7c3aed);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 12px;
        }

        /* TRANSCRIPT SEGMENT */
        .transcript-segment {
            margin: 10px 0;
            padding: 12px;
            border-left: 4px solid;
            background: #f9fafb;
            border-radius: 8px;
            transition: all 0.3s;
        }
        .transcript-segment:hover {
            transform: translateX(3px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .transcript-segment.speaker-1-segment { border-left-color: #3b82f6; }
        .transcript-segment.speaker-2-segment { border-left-color: #10b981; }
        .transcript-segment.speaker-3-segment { border-left-color: #f59e0b; }
        .transcript-segment.speaker-4-segment { border-left-color: #ef4444; }
        .transcript-segment.speaker-5-segment { border-left-color: #8b5cf6; }

        .segment-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            font-size: 13px;
        }
        .segment-text {
            line-height: 1.6;
            color: #1f2937;
        }

        /* BUTTONS */
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-primary { background: #667eea; color: white; }
        .btn-primary:hover:not(:disabled) { background: #5568d3; transform: translateY(-2px); }

        .btn-success { background: #10b981; color: white; }
        .btn-success:hover:not(:disabled) { background: #059669; }

        .btn-warning { background: #f59e0b; color: white; }
        .btn-warning:hover:not(:disabled) { background: #d97706; }

        .btn-secondary { background: #6b7280; color: white; }
        .btn-secondary:hover:not(:disabled) { background: #4b5563; }

        .btn-danger { background: #ef4444; color: white; }
        .btn-danger:hover:not(:disabled) { background: #dc2626; }

        .btn.recording { 
            background: #ef4444; 
            animation: pulse 1.5s infinite; 
        }
        @keyframes pulse {
            0%,100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* TRANSCRIPTION AREA */
        .transcript-area {
            background: #f9fafb;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 20px;
            min-height: 300px;
            max-height: 500px;
            overflow-y: auto;
            margin-bottom: 20px;
            font-size: 16px;
            line-height: 1.8;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .transcript-area.empty {
            color: #9ca3af;
            font-style: italic;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* STATUS */
        .status {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: 500;
            display: none;
            align-items: center;
            gap: 10px;
        }
        .status.active { display: flex; }
        .status.success { background: #dcfce7; color: #166534; }
        .status.error { background: #fee2e2; color: #991b1b; }
        .status.info { background: #dbeafe; color: #1e40af; }
        .status.loading { background: #fef3c7; color: #92400e; }

        .spinner {
            border: 3px solid #f3f4f6;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* ANALYSIS */
        .analysis-section {
            background: #f9fafb;
            border-left: 4px solid #667eea;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .analysis-section h3 {
            color: #667eea;
            margin-bottom: 10px;
        }
        .analysis-content {
            line-height: 1.6;
            color: #374151;
        }

        /* FORM ELEMENTS */
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #374151;
        }
        select, input[type="text"], input[type="password"], textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 15px;
            margin-bottom: 15px;
            transition: border-color 0.3s;
        }
        select:focus, input:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
        }
        textarea {
            min-height: 200px;
            resize: vertical;
            font-family: inherit;
        }
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #667eea;
        }

        /* AUDIO PLAYER */
        audio {
            width: 100%;
            margin: 15px 0;
        }

        /* RESPONSIVE */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            h1 {
                font-size: 24px;
            }
            .btn {
                flex: 1;
                min-width: 120px;
            }
        }
    </style>
</head>
<body>
<div class="container">

<h1>üé§ Trascrizione e Analisi Audio Pro</h1>
<p class="subtitle">Trascrizione avanzata + analisi con AI</p>

<div id="apiKeyNotice" class="info-box" style="background:#dbeafe;border-left:4px solid #3b82f6;margin-bottom:20px;">
    üí° <strong>Suggerimento:</strong> Per trascrivere file audio gi√† registrati, ottieni una <strong>API Key gratuita</strong> di Groq:
    <a href="https://console.groq.com" target="_blank" style="color:#667eea;text-decoration:underline;">console.groq.com</a>
    <br><small style="color:#6b7280;">Poi inseriscila nella tab "üîç Analisi" per sbloccare Whisper AI e le funzioni di analisi.</small>
</div>

<div id="status" class="status"></div>

<!-- TABS -->
<div class="tabs">
    <button class="tab active" data-tab="record">üéôÔ∏è Registra</button>
    <button class="tab" data-tab="upload">üìÅ Carica File</button>
    <button class="tab" data-tab="paste">üìù Incolla Testo</button>
    <button class="tab" data-tab="analysis">üîç Analisi</button>
    <button class="tab" data-tab="settings">‚öôÔ∏è Impostazioni</button>
</div>

<!-- TAB REGISTRAZIONE -->
<div class="tab-content active" id="tab-record">

    <div class="info-box" style="background:#fef3c7;border-left:4px solid #f59e0b;">
        üé§ <strong>Due metodi di registrazione:</strong><br>
        <strong>‚Ä¢ Tempo Reale:</strong> Trascrizione immediata mentre parli (browser)<br>
        <strong>‚Ä¢ Registra + Trascrivi:</strong> Prima registra in alta qualit√†, poi trascrivi con Whisper AI<br>
        <small style="color:#92400e;">üí° Registra + Trascrivi usa audio professionale fino a 48kHz con riduzione rumore avanzata</small>
    </div>
    
    <div class="info-box" style="background:#dbeafe;border-left:4px solid #3b82f6;">
        üë• <strong>Riconoscimento Parlanti Automatico</strong><br>
        Il sistema rileva automaticamente quando cambia il parlante (dopo 2 secondi di pausa).<br>
        Ogni parlante avr√† un colore distintivo nella trascrizione!<br>
        <small style="color:#1e40af;">üéØ Perfetto per interviste, podcast, riunioni e conversazioni multi-persona</small>
    </div>

    <div class="button-group">
        <button class="btn btn-warning" id="testMicBtn">üîä Testa Microfono</button>
        <select id="currentSpeakerSelect" style="margin-right:10px;padding:8px;border-radius:8px;border:1px solid #d1d5db;">
            <option value="1">Parlante 1</option>
            <option value="2">Parlante 2</option>
            <option value="3">Parlante 3</option>
            <option value="4">Parlante 4</option>
            <option value="5">Parlante 5</option>
        </select>
        <button class="btn btn-secondary" id="forceSpeakerBtn">üîÑ Imposta Parlante</button>
    </div>

    <div id="microphoneStatus" style="display:none;padding:15px;border-radius:10px;margin-bottom:20px;font-weight:500;">
        <div id="micStatusText"></div>
        <div id="micVolumeMeter" style="margin-top:10px;display:none;">
            <div style="background:#e5e7eb;border-radius:5px;height:10px;overflow:hidden;">
                <div id="volumeBar" style="background:#10b981;height:100%;width:0%;transition:width .1s;"></div>
            </div>
        </div>
    </div>

    <div id="micInstructions" class="info-box" 
         style="display:none;background:#fee2e2;border-left:4px solid #ef4444;color:#991b1b;">
        ‚ùå <strong>Permesso microfono negato</strong><br>
        Per riattivarlo, clicca sull'icona del lucchetto nella barra degli indirizzi e consenti l'accesso al microfono.
    </div>

    <div id="apiKeyNoticeRec" class="info-box" 
         style="display:none;background:#fef3c7;border-left:4px solid #f59e0b;">
        üîë <strong>API Key Groq richiesta per Whisper AI</strong><br>
        Per usare il metodo "Registra + Trascrivi", vai nella tab "‚öôÔ∏è Impostazioni" e inserisci la tua API Key gratuita.
        <button class="btn btn-primary" onclick="document.querySelectorAll('.tab')[4].click();" style="margin-top:10px;">
            ‚Üí Vai alle Impostazioni
        </button>
    </div>

    <div style="margin-bottom:20px;">
        <label>Metodo di registrazione:</label>
        <select id="recordingMode">
            <option value="realtime">üé§ Tempo Reale (trascrizione immediata)</option>
            <option value="record-then-transcribe">üéôÔ∏è Registra + Trascrivi con Whisper AI</option>
        </select>
    </div>

    <div class="button-group">
        <button class="btn btn-success" id="recordBtn">
            <span id="recordBtnText">‚ñ∂Ô∏è Inizia Registrazione</span>
        </button>
        <button class="btn btn-secondary" id="resumeBtn" style="display:none;">
            ‚Ü©Ô∏è Riprendi Ultima Registrazione
        </button>
    </div>

    <!-- Sezione per Registra + Trascrivi -->
    <div id="recordedAudioSection" style="display:none;margin-bottom:20px;">
        <div class="info-box" style="background:#dcfce7;border-left:4px solid #10b981;">
            ‚úÖ <strong>Registrazione completata!</strong><br>
            Ora puoi trascrivere il tuo audio con Whisper AI.
        </div>
        
        <div style="padding:10px;background:#f3f4f6;border-radius:8px;margin-bottom:15px;">
            <div style="display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:10px;">
                <div>
                    <strong id="recordedFileName">registrazione.webm</strong>
                    <div style="font-size:12px;color:#6b7280;" id="recordedFileInfo">0:00 ‚Ä¢ 0.0 KB</div>
                </div>
            </div>
        </div>

        <audio id="recordedAudioPlayer" controls style="width:100%;margin-bottom:15px;"></audio>

        <div class="button-group">
            <button class="btn btn-primary" id="transcribeRecordedBtn">ü§ñ Trascrivi con Whisper AI</button>
            <button class="btn btn-success" id="downloadRecordedBtn">üíæ Scarica Audio</button>
            <button class="btn btn-secondary" id="newRecordingBtn">üîÑ Nuova Registrazione</button>
        </div>
    </div>

    <div id="recordingStats" style="display:none;padding:10px;background:#dcfce7;border-radius:8px;margin-bottom:15px;text-align:center;font-weight:500;color:#166534;">
        <span id="wordCount">0 parole trascritte</span> ‚Ä¢ 
        <span id="speakerCount">0 parlanti</span> ‚Ä¢ 
        <span id="recordingTime">00:00</span>
    </div>

    <div class="transcript-area empty" id="liveTranscript">
        La trascrizione in tempo reale apparir√† qui...
    </div>

</div>

<!-- TAB CARICA FILE -->
<div class="tab-content" id="tab-upload">

    <div class="info-box" style="background:#d1fae5;border-left:4px solid #10b981;">
        üéß <strong>Carica un file audio gi√† registrato</strong><br>
        Trascrizione automatica con AI (Whisper) - Veloce e precisa!<br>
        <small style="color:#059669;">üí° Tip: Registra un vocale sul telefono e caricalo qui per testare!</small>
    </div>

    <div id="whisperNotice" class="info-box" style="background:#fef3c7;border-left:4px solid #f59e0b;display:none;">
        üîë <strong>Come ottenere l'API Key Groq (gratuita):</strong>
        <ol style="margin:10px 0 0 20px;line-height:1.8;">
            <li>Vai su <a href="https://console.groq.com" target="_blank" style="color:#d97706;text-decoration:underline;font-weight:600;">console.groq.com</a></li>
            <li>Crea un account gratuito (con Google/GitHub)</li>
            <li>Clicca su "API Keys" ‚Üí "Create API Key"</li>
            <li>Copia la chiave e incollala nella tab "‚öôÔ∏è Impostazioni"</li>
        </ol>
        <button class="btn btn-primary" onclick="document.querySelectorAll('.tab')[4].click();" style="margin-top:10px;">
            ‚Üí Vai alle Impostazioni
        </button>
    </div>

    <div class="upload-area" id="uploadArea">
        <div class="upload-icon">üì§</div>
        <h3>Trascina un file audio o clicca per caricare</h3>
        <p style="color:#6b7280;">Formati supportati: MP3, WAV, M4A, OGG, WebM, FLAC</p>
        <input type="file" id="audioFile" accept="audio/*" style="display:none;">
    </div>

    <div id="audioFileName" style="padding:10px;background:#f3f4f6;border-radius:8px;margin-bottom:15px;display:none;"></div>

    <audio id="audioPlayer" controls style="display:none;"></audio>

    <div style="margin-bottom:20px;display:none;" id="transcriptionMethodSection">
        <label>Metodo di trascrizione:</label>
        <select id="transcriptionMethod">
            <option value="whisper">ü§ñ Whisper AI (Groq) - Consigliato</option>
            <option value="browser">üé§ Browser (riproduci + cattura)</option>
        </select>
        <small style="display:block;margin-top:5px;color:#6b7280;">
            <strong>Whisper AI:</strong> Trascrizione diretta del file (richiede API Key Groq gratuita)<br>
            <strong>Browser:</strong> Riproduce l'audio e lo cattura con il microfono
        </small>
    </div>

    <div class="button-group">
        <button class="btn btn-primary" id="transcribeAudioBtn" disabled>
            <span id="transcribeAudioBtnText">üéØ Trascrivi File</span>
        </button>
        <button class="btn btn-danger" id="stopTranscriptionBtn" style="display:none;">‚èπÔ∏è Ferma</button>
    </div>

    <div id="transcriptionProgress" style="display:none;padding:15px;background:#fef3c7;border-radius:10px;margin-bottom:15px;">
        <div style="display:flex;align-items:center;gap:10px;margin-bottom:10px;">
            <div class="spinner"></div>
            <span id="progressText">Trascrizione in corso...</span>
        </div>
        <div style="background:#e5e7eb;border-radius:5px;height:8px;overflow:hidden;">
            <div id="progressBar" style="background:#667eea;height:100%;width:0%;transition:width 0.3s;"></div>
        </div>
    </div>

    <div class="transcript-area empty" id="liveFileTranscript" style="display:none;">
        Trascrizione in corso...
    </div>

    <h3 style="margin:30px 0 15px 0;color:#374151;">üíæ Sessioni Salvate</h3>

    <div style="margin-bottom:15px;">
        <input type="text" id="sessionName" placeholder="Nome della sessione" style="padding:8px;border:1px solid #d1d5db;border-radius:4px;width:200px;">
        <button class="btn btn-success" id="saveSessionBtn">üíæ Salva Sessione</button>
    </div>

    <div id="savedSessionsList" style="max-height:300px;overflow-y:auto;border:1px solid #e5e7eb;border-radius:8px;padding:10px;background:#f9fafb;">
        <div style="text-align:center;color:#6b7280;padding:20px;" id="noSessionsMsg">
            Nessuna sessione salvata
        </div>
    </div>

</div>

<!-- TAB INCOLLA TESTO -->
<div class="tab-content" id="tab-paste">

    <div class="info-box" style="background:#dbeafe;border-left:4px solid #3b82f6;">
        üìù <strong>Incolla il testo</strong><br>
        Puoi incollare un testo gi√† trascritto per analizzarlo.
    </div>

    <label>Testo da analizzare:</label>
    <textarea id="pastedText" placeholder="Incolla qui il tuo testo..."></textarea>

    <div class="button-group">
        <button class="btn btn-primary" id="usePastedTextBtn">‚úÖ Usa Questo Testo</button>
    </div>

</div>

<!-- TAB ANALISI -->
<div class="tab-content" id="tab-analysis">

    <div class="info-box" style="background:#fef3c7;border-left:4px solid #f59e0b;" id="analysisInfo">
        ‚ö†Ô∏è <strong>Nessuna trascrizione disponibile</strong><br>
        Prima registra, carica un file o incolla del testo.
    </div>

    <h3 style="margin-bottom:15px;color:#374151;">üìÑ Trascrizione</h3>
    <div class="transcript-area" id="mainTranscript">
        Nessuna trascrizione disponibile.
    </div>

    <div class="button-group">
        <button class="btn btn-primary" id="correctTextBtn" disabled>‚ú® Correggi Testo</button>
        <button class="btn btn-primary" id="summarizeBtn" disabled>üìù Riassumi</button>
        <button class="btn btn-primary" id="analyzeBtn" disabled>üîç Analizza</button>
        <button class="btn btn-primary" id="identifySpeakersBtn" disabled>üë• Identifica Parlanti</button>
    </div>

    <div class="button-group">
        <button class="btn btn-success" id="exportPdfBtn" disabled>üìÑ Esporta PDF</button>
        <button class="btn btn-success" id="exportTxtBtn" disabled>üìù Esporta TXT</button>
        <button class="btn btn-danger" id="clearBtn">üóëÔ∏è Cancella Tutto</button>
    </div>

    <div id="analysisResults" style="margin-top:30px;"></div>

</div>

<!-- TAB IMPOSTAZIONI -->
<div class="tab-content" id="tab-settings">

    <h3 style="margin-bottom:20px;color:#374151;">‚öôÔ∏è Impostazioni Generali</h3>

    <div style="margin-bottom:20px;">
        <label>Lingua di trascrizione:</label>
        <select id="language">
            <option value="it-IT">Italiano</option>
            <option value="en-US">Inglese (US)</option>
            <option value="en-GB">Inglese (UK)</option>
            <option value="es-ES">Spagnolo</option>
            <option value="fr-FR">Francese</option>
            <option value="de-DE">Tedesco</option>
        </select>
    </div>

    <div id="audioQualitySection" style="margin-bottom:20px;padding:15px;background:#f9fafb;border-radius:10px;border:2px solid #e5e7eb;">
        <label style="margin-bottom:10px;">‚öôÔ∏è Qualit√† audio:</label>
        <select id="audioQuality" style="margin-bottom:10px;">
            <option value="low">Bassa (22kHz, 128kbps)</option>
            <option value="medium" selected>Standard (44kHz, 192kbps)</option>
            <option value="high">Alta (48kHz, 256kbps)</option>
        </select>
        
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;">
            <label style="display:flex;align-items:center;gap:5px;font-size:14px;cursor:pointer;" title="Riduce il rumore di fondo ambientale">
                <input type="checkbox" id="noiseSuppression" checked>
                üîá Soppressione rumore
            </label>
            <label style="display:flex;align-items:center;gap:5px;font-size:14px;cursor:pointer;" title="Elimina l'eco e il riverbero">
                <input type="checkbox" id="echoCancellation" checked>
                üîä Cancellazione eco
            </label>
            <label style="display:flex;align-items:center;gap:5px;font-size:14px;cursor:pointer;" title="Normalizza automaticamente il volume">
                <input type="checkbox" id="autoGainControl" checked>
                üìä Guadagno auto
            </label>
        </div>
        
        <div style="margin-top:10px;padding:10px;background:#dbeafe;border-radius:8px;font-size:12px;color:#1e40af;">
            üí° <strong>Consiglio:</strong> Usa "Alta" per interviste e podcast. "Standard" per appunti rapidi.
        </div>
    </div>

    <div style="margin-bottom:20px;">
        <label><strong>üë• Nomi Parlanti (opzionali):</strong></label>
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:10px;margin-top:10px;">
            <div>
                <label for="speaker1">Parlante 1:</label>
                <input type="text" id="speaker1" placeholder="Nome parlante 1" style="width:100%;padding:5px;border:1px solid #d1d5db;border-radius:4px;">
            </div>
            <div>
                <label for="speaker2">Parlante 2:</label>
                <input type="text" id="speaker2" placeholder="Nome parlante 2" style="width:100%;padding:5px;border:1px solid #d1d5db;border-radius:4px;">
            </div>
            <div>
                <label for="speaker3">Parlante 3:</label>
                <input type="text" id="speaker3" placeholder="Nome parlante 3" style="width:100%;padding:5px;border:1px solid #d1d5db;border-radius:4px;">
            </div>
            <div>
                <label for="speaker4">Parlante 4:</label>
                <input type="text" id="speaker4" placeholder="Nome parlante 4" style="width:100%;padding:5px;border:1px solid #d1d5db;border-radius:4px;">
            </div>
            <div>
                <label for="speaker5">Parlante 5:</label>
                <input type="text" id="speaker5" placeholder="Nome parlante 5" style="width:100%;padding:5px;border:1px solid #d1d5db;border-radius:4px;">
            </div>
        </div>
    </div>

    <div style="margin-bottom:20px;">
        <label>API Key Groq (necessaria per trascrizione file e analisi AI):</label>
        <input type="password" id="groqApiKey" placeholder="gsk_...">
        <div id="apiKeyNotice" class="info-box" style="background:#fef3c7;border-left:4px solid #f59e0b;margin-top:10px;display:none;">
            üîë <strong>Come ottenere l'API Key Groq (gratuita):</strong><br>
            1. Vai su <a href="https://console.groq.com/" target="_blank">console.groq.com</a><br>
            2. Registrati con email<br>
            3. Crea una nuova API Key<br>
            4. Copia e incolla qui sopra<br>
            <small style="color:#92400e;">üí° L'API √® gratuita per uso personale fino a 500 richieste/giorno</small>
        </div>
    </div>

    <div style="margin-bottom:20px;">
        <button class="btn btn-secondary" onclick="clearAllData()">üóëÔ∏è Cancella Tutti i Dati</button>
        <small style="display:block;margin-top:5px;color:#6b7280;">Cancella trascrizioni salvate, nomi parlanti e impostazioni</small>
    </div>

</div>

</div>

<script>
/* ===========================================
   VARIABILI GLOBALI
=========================================== */

// Elementi DOM
const tabs = document.querySelectorAll('.tab');
const tabContents = document.querySelectorAll('.tab-content');
const statusDiv = document.getElementById('status');

// Tab Registrazione
const testMicBtn = document.getElementById('testMicBtn');
const recordBtn = document.getElementById('recordBtn');
const resumeBtn = document.getElementById('resumeBtn');
const recordBtnText = document.getElementById('recordBtnText');
const liveTranscript = document.getElementById('liveTranscript');
const languageSelect = document.getElementById('language');
const recordingMode = document.getElementById('recordingMode');
const audioQualitySection = document.getElementById('audioQualitySection');
const audioQuality = document.getElementById('audioQuality');
const noiseSuppression = document.getElementById('noiseSuppression');
const echoCancellation = document.getElementById('echoCancellation');
const autoGainControl = document.getElementById('autoGainControl');
const microphoneStatus = document.getElementById('microphoneStatus');
const micStatusText = document.getElementById('micStatusText');
const micVolumeMeter = document.getElementById('micVolumeMeter');
const volumeBar = document.getElementById('volumeBar');
const micInstructions = document.getElementById('micInstructions');

// Recorder elements
const recordedAudioSection = document.getElementById('recordedAudioSection');
const recordedAudioPlayer = document.getElementById('recordedAudioPlayer');
const recordedFileName = document.getElementById('recordedFileName');
const recordedFileInfo = document.getElementById('recordedFileInfo');
const transcribeRecordedBtn = document.getElementById('transcribeRecordedBtn');
const downloadRecordedBtn = document.getElementById('downloadRecordedBtn');
const newRecordingBtn = document.getElementById('newRecordingBtn');

// Recording stats
const recordingStats = document.getElementById('recordingStats');
const wordCount = document.getElementById('wordCount');
const speakerCountDisplay = document.getElementById('speakerCount');
const recordingTime = document.getElementById('recordingTime');
let recordingStartTime = null;
let recordingInterval = null;

// Tab Upload
const uploadArea = document.getElementById('uploadArea');
const audioFileInput = document.getElementById('audioFile');
const audioFileName = document.getElementById('audioFileName');
const audioPlayer = document.getElementById('audioPlayer');
const transcribeAudioBtn = document.getElementById('transcribeAudioBtn');
const transcribeAudioBtnText = document.getElementById('transcribeAudioBtnText');
const stopTranscriptionBtn = document.getElementById('stopTranscriptionBtn');
const liveFileTranscript = document.getElementById('liveFileTranscript');
const transcriptionMethod = document.getElementById('transcriptionMethod');
const transcriptionMethodSection = document.getElementById('transcriptionMethodSection');

// Sessioni salvate
const sessionName = document.getElementById('sessionName');
const saveSessionBtn = document.getElementById('saveSessionBtn');
const savedSessionsList = document.getElementById('savedSessionsList');
const noSessionsMsg = document.getElementById('noSessionsMsg');
const transcriptionProgress = document.getElementById('transcriptionProgress');
const progressBar = document.getElementById('progressBar');
const progressText = document.getElementById('progressText');
const whisperNotice = document.getElementById('whisperNotice');

// Tab Incolla
const pastedText = document.getElementById('pastedText');
const usePastedTextBtn = document.getElementById('usePastedTextBtn');

// Tab Analisi
const groqApiKey = document.getElementById('groqApiKey');
const mainTranscript = document.getElementById('mainTranscript');
const correctTextBtn = document.getElementById('correctTextBtn');
const summarizeBtn = document.getElementById('summarizeBtn');
const analyzeBtn = document.getElementById('analyzeBtn');
const identifySpeakersBtn = document.getElementById('identifySpeakersBtn');
const exportPdfBtn = document.getElementById('exportPdfBtn');
const exportTxtBtn = document.getElementById('exportTxtBtn');
const clearBtn = document.getElementById('clearBtn');
const analysisResults = document.getElementById('analysisResults');
const analysisInfo = document.getElementById('analysisInfo');

// Variabili stato
let recognition = null;
let isRecording = false;
let transcript = "";
if (localStorage.getItem('transcriptText')) {
    transcript = localStorage.getItem('transcriptText');
}
let fileTranscript = "";
let fileTranscriptionActive = false;
let currentAudioFile = null;
let audioContext = null;
let analyser = null;
let microphone = null;

// Nomi parlanti
let speakerNames = {};
if (localStorage.getItem('speakerNames')) {
    speakerNames = JSON.parse(localStorage.getItem('speakerNames'));
}

// Sessioni salvate
let savedSessions = [];
if (localStorage.getItem('savedSessions')) {
    savedSessions = JSON.parse(localStorage.getItem('savedSessions'));
}

// Variabili multi-parlante
let speakers = new Map();
let currentSpeaker = 1;
let lastSpeechTime = Date.now();
let isFirstSpeech = true;
const SPEAKER_PAUSE_THRESHOLD = 2000; // 2 secondi di pausa per cambio parlante

// Variabili analisi audio per riconoscimento tono
let lastFrequencies = new Map(); // speakerId to last frequency
let lastAssignedSpeaker = 1;
const TONE_CHANGE_THRESHOLD = 50; // Hz differenza per cambio parlante

// Variabili per raggruppamento segmenti
let lastSegment = null;
let lastSegmentSpeaker = null;
let lastSegmentTime = 0;
const SEGMENT_GROUP_THRESHOLD = 10000; // 10 secondi per raggruppare segmenti dello stesso parlante

// Carica nomi parlanti salvati
for (let i = 1; i <= 5; i++) {
    const name = localStorage.getItem('speaker' + i);
    if (name) {
        speakerNames[i] = name;
        const input = document.getElementById('speaker' + i);
        if (input) input.value = name;
    }
}

// Event listeners per salvare nomi parlanti
for (let i = 1; i <= 5; i++) {
    document.getElementById('speaker' + i).addEventListener('input', (e) => {
        const name = e.target.value.trim();
        if (name) {
            speakerNames[i] = name;
            localStorage.setItem('speaker' + i, name);
        } else {
            delete speakerNames[i];
            localStorage.removeItem('speaker' + i);
        }
        updateSpeakerSelect();
    });
}

// Funzione per aggiornare il select dei parlanti
function updateSpeakerSelect() {
    const select = document.getElementById('currentSpeakerSelect');
    for (let i = 1; i <= 5; i++) {
        const option = select.options[i-1];
        option.text = speakerNames[i] || 'Parlante ' + i;
    }
}

// Inizializza select
updateSpeakerSelect();

// Funzione per rilevamento pitch tramite autocorrelazione
function detectPitch(buffer, sampleRate) {
    const minPeriod = Math.floor(sampleRate / 500); // max 500 Hz
    const maxPeriod = Math.floor(sampleRate / 50); // min 50 Hz
    let bestPeriod = 0;
    let bestCorrelation = 0;
    
    for (let period = minPeriod; period < maxPeriod; period++) {
        let correlation = 0;
        const maxSamples = Math.min(buffer.length - period, 1024); // limita per performance
        for (let i = 0; i < maxSamples; i++) {
            correlation += buffer[i] * buffer[i + period];
        }
        if (correlation > bestCorrelation) {
            bestCorrelation = correlation;
            bestPeriod = period;
        }
    }
    
    if (bestPeriod > 0) {
        return sampleRate / bestPeriod;
    }
    return null;
}

// MediaRecorder variables
let mediaRecorder = null;
let recordedChunks = [];
let recordedBlob = null;
let recordingStream = null;

/* ===========================================
   INIZIALIZZAZIONE
=========================================== */

// Carica dati salvati
if (localStorage.getItem('transcript')) {
    const saved = localStorage.getItem('transcript');
    mainTranscript.innerHTML = saved;
    enableAnalysisButtons();
}

if (localStorage.getItem('groqKey')) {
    groqApiKey.value = localStorage.getItem('groqKey');
    // Nascondi notice se l'utente ha gi√† una chiave
    const apiKeyNotice = document.getElementById('apiKeyNotice');
    if (apiKeyNotice) apiKeyNotice.style.display = 'none';
}

// Carica impostazioni qualit√† audio
if (localStorage.getItem('audioQuality')) {
    audioQuality.value = localStorage.getItem('audioQuality');
}
if (localStorage.getItem('noiseSuppression') !== null) {
    noiseSuppression.checked = localStorage.getItem('noiseSuppression') === 'true';
}
if (localStorage.getItem('echoCancellation') !== null) {
    echoCancellation.checked = localStorage.getItem('echoCancellation') === 'true';
}
if (localStorage.getItem('autoGainControl') !== null) {
    autoGainControl.checked = localStorage.getItem('autoGainControl') === 'true';
}

// Carica nomi parlanti negli input
for (let i = 1; i <= 5; i++) {
    const input = document.getElementById('speaker' + i);
    if (input && speakerNames[i]) {
        input.value = speakerNames[i];
    }
}

// Salva impostazioni qualit√† audio quando cambiano
audioQuality.addEventListener('change', () => {
    localStorage.setItem('audioQuality', audioQuality.value);
});
noiseSuppression.addEventListener('change', () => {
    localStorage.setItem('noiseSuppression', noiseSuppression.checked);
});
echoCancellation.addEventListener('change', () => {
    localStorage.setItem('echoCancellation', echoCancellation.checked);
});
autoGainControl.addEventListener('change', () => {
    localStorage.setItem('autoGainControl', autoGainControl.checked);
});

// Salva nomi parlanti quando cambiano
for (let i = 1; i <= 5; i++) {
    const input = document.getElementById('speaker' + i);
    if (input) {
        input.addEventListener('input', saveSpeakerNames);
    }
}

// Speech Recognition
if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    recognition = new SpeechRecognition();
} else {
    showStatus('‚ùå Browser non supporta il riconoscimento vocale', 'error');
}

// Set initial button text based on recording mode
if (recordingMode.value === 'record-then-transcribe') {
    recordBtnText.textContent = '‚ñ∂Ô∏è Registra Audio';
}

/* ===========================================
   GESTIONE TABS
=========================================== */

tabs.forEach(tab => {
    tab.addEventListener('click', () => {
        const targetTab = tab.dataset.tab;
        
        tabs.forEach(t => t.classList.remove('active'));
        tabContents.forEach(tc => tc.classList.remove('active'));
        
        tab.classList.add('active');
        document.getElementById(`tab-${targetTab}`).classList.add('active');
    });
});

/* ===========================================
   TEST MICROFONO
=========================================== */

testMicBtn.addEventListener('click', async () => {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
                sampleRate: { ideal: 48000 }
            } 
        });
        
        microphoneStatus.style.display = 'block';
        microphoneStatus.style.background = '#dcfce7';
        microphoneStatus.style.color = '#166534';
        micStatusText.innerHTML = '‚úÖ Microfono funzionante!<br><small style="color:#059669;">Configurato per alta qualit√†</small>';
        micVolumeMeter.style.display = 'block';
        
        // Analisi volume
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        microphone = audioContext.createMediaStreamSource(stream);
        microphone.connect(analyser);
        analyser.fftSize = 256;
        
        const dataArray = new Uint8Array(analyser.frequencyBinCount);
        
        function updateVolume() {
            analyser.getByteFrequencyData(dataArray);
            const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
            const volume = Math.min(100, (average / 128) * 100);
            volumeBar.style.width = volume + '%';
            
            if (micVolumeMeter.style.display !== 'none') {
                requestAnimationFrame(updateVolume);
            }
        }
        updateVolume();
        
        setTimeout(() => {
            stream.getTracks().forEach(track => track.stop());
            if (audioContext) audioContext.close();
            micVolumeMeter.style.display = 'none';
        }, 5000);
        
    } catch (err) {
        microphoneStatus.style.display = 'block';
        microphoneStatus.style.background = '#fee2e2';
        microphoneStatus.style.color = '#991b1b';
        micStatusText.textContent = '‚ùå Impossibile accedere al microfono';
        micInstructions.style.display = 'block';
    }
});

// Cambio parlante manuale
document.getElementById('forceSpeakerBtn').addEventListener('click', () => {
    const selectedId = parseInt(document.getElementById('currentSpeakerSelect').value);
    lastAssignedSpeaker = selectedId;
    lastFrequencies.set(lastAssignedSpeaker, null);
    const speakerLabel = speakerNames[lastAssignedSpeaker] || 'Parlante ' + lastAssignedSpeaker;
    showStatus('üîÑ Parlante impostato manualmente a ' + speakerLabel, 'info');
});

/* ===========================================
   REGISTRAZIONE AUDIO (Record + Transcribe)
=========================================== */

async function startAudioRecording() {
    try {
        // Determina i parametri di qualit√† in base alla selezione
        let sampleRate, audioBitsPerSecond;
        const qualityLevel = audioQuality.value;
        
        switch(qualityLevel) {
            case 'high':
                sampleRate = 48000;  // Qualit√† professionale
                audioBitsPerSecond = 256000;  // 256 kbps
                break;
            case 'medium':
                sampleRate = 44100;  // Qualit√† CD
                audioBitsPerSecond = 192000;  // 192 kbps
                break;
            case 'standard':
                sampleRate = 16000;  // Qualit√† voce
                audioBitsPerSecond = 128000;  // 128 kbps
                break;
            default:
                sampleRate = 48000;
                audioBitsPerSecond = 256000;
        }
        
        // Configurazione avanzata del microfono
        const audioConstraints = {
            audio: {
                echoCancellation: echoCancellation.checked,
                noiseSuppression: noiseSuppression.checked,
                autoGainControl: autoGainControl.checked,
                sampleRate: { ideal: sampleRate },
                sampleSize: { ideal: 16 },
                channelCount: { ideal: 2 },  // Stereo
            }
        };
        
        const recorderOptions = {
            mimeType: mimeType,
            audioBitsPerSecond: audioBitsPerSecond
        };
        
        // Rimuovi mimeType se vuoto
        if (!mimeType) delete recorderOptions.mimeType;
        
        mediaRecorder = new MediaRecorder(recordingStream, recorderOptions);
        
        console.log(`Registrazione avviata: ${sampleRate}Hz, ${audioBitsPerSecond/1000}kbps, ${mimeType || 'default'}`);
        
        mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
                recordedChunks.push(event.data);
            }
        };
        
        mediaRecorder.onstop = () => {
            const blobType = mimeType || 'audio/webm';
            recordedBlob = new Blob(recordedChunks, { type: blobType });
            displayRecordedAudio();
        };
        
        mediaRecorder.start();
        isRecording = true;
        
        recordBtn.classList.add('recording');
        recordBtnText.textContent = '‚èπÔ∏è Ferma Registrazione';
        
        // Setup volume visualization
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        microphone = audioContext.createMediaStreamSource(recordingStream);
        microphone.connect(analyser);
        analyser.fftSize = 256;
        
        const dataArray = new Uint8Array(analyser.frequencyBinCount);
        
        function updateVolume() {
            if (!isRecording) return;
            
            analyser.getByteFrequencyData(dataArray);
            const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
            const volume = Math.min(100, (average / 128) * 100);
            
            // Update word count area to show volume
            wordCount.innerHTML = `<div style="display:flex;align-items:center;gap:10px;">
                <span>Volume:</span>
                <div style="flex:1;background:#e5e7eb;border-radius:5px;height:10px;overflow:hidden;">
                    <div style="background:#10b981;height:100%;width:${volume}%;transition:width .1s;"></div>
                </div>
                <span style="font-size:12px;color:#6b7280;">${qualityLevel === 'high' ? 'üéØ' : qualityLevel === 'medium' ? '‚ö°' : 'üíæ'} ${sampleRate/1000}kHz</span>
            </div>`;
            
            requestAnimationFrame(updateVolume);
        }
        updateVolume();
        
        // Mostra timer
        recordingStats.style.display = 'block';
        recordingStartTime = Date.now();
        
        recordingInterval = setInterval(() => {
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            recordingTime.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }, 1000);
        
        showStatus(`üéôÔ∏è Registrazione ${qualityLevel === 'high' ? 'alta qualit√†' : qualityLevel === 'medium' ? 'media qualit√†' : 'standard'} in corso...`, 'info');
        
    } catch (err) {
        showStatus('‚ùå Impossibile accedere al microfono: ' + err.message, 'error');
        micInstructions.style.display = 'block';
    }
}

function stopAudioRecording() {
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
    }
    
    if (recordingStream) {
        recordingStream.getTracks().forEach(track => track.stop());
    }
    
    // Cleanup audio context
    if (audioContext) {
        audioContext.close();
        audioContext = null;
    }
    
    isRecording = false;
    recordBtn.classList.remove('recording');
    recordBtnText.textContent = '‚ñ∂Ô∏è Registra Audio';
    
    // Ferma timer
    if (recordingInterval) {
        clearInterval(recordingInterval);
        recordingInterval = null;
    }
    
    setTimeout(() => {
        recordingStats.style.display = 'none';
    }, 1000);
}

function displayRecordedAudio() {
    const url = URL.createObjectURL(recordedBlob);
    recordedAudioPlayer.src = url;
    
    // Calcola durata e dimensione
    const durationSeconds = Math.floor((Date.now() - recordingStartTime) / 1000);
    const minutes = Math.floor(durationSeconds / 60);
    const seconds = durationSeconds % 60;
    const sizeMB = (recordedBlob.size / (1024 * 1024)).toFixed(2);
    const sizeKB = (recordedBlob.size / 1024).toFixed(1);
    
    const qualityLabel = audioQuality.value === 'high' ? 'üéØ Alta' : 
                        audioQuality.value === 'medium' ? '‚ö° Media' : 'üíæ Standard';
    
    const fileExtension = recordedBlob.type.includes('webm') ? 'webm' : 
                         recordedBlob.type.includes('ogg') ? 'ogg' : 
                         recordedBlob.type.includes('mp4') ? 'm4a' : 'audio';
    
    recordedFileName.textContent = `registrazione_${new Date().toISOString().slice(0,10)}.${fileExtension}`;
    recordedFileInfo.textContent = `${minutes}:${String(seconds).padStart(2, '0')} ‚Ä¢ ${sizeMB > 1 ? sizeMB + ' MB' : sizeKB + ' KB'} ‚Ä¢ ${qualityLabel}`;
    
    recordedAudioSection.style.display = 'block';
    liveTranscript.style.display = 'none';
    
    showStatus(`‚úÖ Registrazione ${qualityLabel.toLowerCase()} completata! Ora puoi trascriverla.`, 'success');
}

// Trascrivi audio registrato
transcribeRecordedBtn.addEventListener('click', async () => {
    if (!recordedBlob) {
        showStatus('‚ùå Nessuna registrazione disponibile', 'error');
        return;
    }
    
    const key = groqApiKey.value.trim();
    if (!key) {
        showStatus('‚ùå Inserisci la tua API Key Groq nella tab Analisi', 'error');
        setTimeout(() => {
            tabs.forEach(t => t.classList.remove('active'));
            tabContents.forEach(tc => tc.classList.remove('active'));
            document.querySelector('[data-tab="analysis"]').classList.add('active');
            document.getElementById('tab-analysis').classList.add('active');
        }, 2000);
        return;
    }
    
    transcribeRecordedBtn.disabled = true;
    showStatus('ü§ñ Trascrizione in corso con Whisper AI...', 'loading');
    
    try {
        // Converti blob in file
        const file = new File([recordedBlob], 'recording.webm', { type: 'audio/webm' });
        
        const formData = new FormData();
        formData.append('file', file);
        formData.append('model', 'whisper-large-v3');
        formData.append('language', languageSelect.value.split('-')[0]);
        formData.append('response_format', 'text');
        
        const response = await fetch('https://api.groq.com/openai/v1/audio/transcriptions', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${key}`
            },
            body: formData
        });
        
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error?.message || `Errore API: ${response.status}`);
        }
        
        const transcriptText = await response.text();
        
        // Mostra trascrizione
        liveTranscript.style.display = 'block';
        liveTranscript.classList.remove('empty');
        liveTranscript.textContent = transcriptText;
        
        // Salva
        mainTranscript.textContent = transcriptText;
        localStorage.setItem('transcript', transcriptText);
        enableAnalysisButtons();
        
        const wordCount = transcriptText.trim().split(/\s+/).length;
        showStatus(`‚úÖ Trascrizione completata! ${wordCount} parole trascritte.`, 'success');
        
        // Passa alla tab analisi
        setTimeout(() => {
            tabs.forEach(t => t.classList.remove('active'));
            tabContents.forEach(tc => tc.classList.remove('active'));
            document.querySelector('[data-tab="analysis"]').classList.add('active');
            document.getElementById('tab-analysis').classList.add('active');
        }, 2000);
        
    } catch (error) {
        showStatus('‚ùå Errore trascrizione: ' + error.message, 'error');
    } finally {
        transcribeRecordedBtn.disabled = false;
    }
});

// Scarica audio registrato
downloadRecordedBtn.addEventListener('click', () => {
    if (!recordedBlob) return;
    
    const fileExtension = recordedBlob.type.includes('webm') ? 'webm' : 
                         recordedBlob.type.includes('ogg') ? 'ogg' : 
                         recordedBlob.type.includes('mp4') ? 'm4a' : 'audio';
    
    const url = URL.createObjectURL(recordedBlob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `registrazione_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.${fileExtension}`;
    a.click();
    
    showStatus('üíæ Download avviato!', 'success');
});

// Nuova registrazione
newRecordingBtn.addEventListener('click', () => {
    recordedAudioSection.style.display = 'none';
    liveTranscript.style.display = 'block';
    liveTranscript.classList.add('empty');
    liveTranscript.textContent = 'La trascrizione in tempo reale apparir√† qui...';
    recordedBlob = null;
    recordedChunks = [];
    
    showStatus('üéôÔ∏è Pronto per una nuova registrazione', 'info');
});

/* ===========================================
   FUNZIONI RICONOSCIMENTO PARLANTI
=========================================== */

function detectSpeakerChange(text, confidence) {
    const currentTime = Date.now();
    const timeSinceLastSpeech = currentTime - lastSpeechTime;
    
    // Analizza tono voce
    console.log('Analyser exists:', !!analyser, 'AudioContext state:', audioContext?.state);
    let currentFrequency = null;
    if (analyser) {
        const bufferLength = analyser.fftSize;
        const timeData = new Float32Array(bufferLength);
        analyser.getFloatTimeDomainData(timeData);
        
        // Calcola volume medio
        let volume = 0;
        let maxVol = 0;
        for (let i = 0; i < timeData.length; i++) {
            const absVal = Math.abs(timeData[i]);
            volume += absVal;
            maxVol = Math.max(maxVol, absVal);
        }
        volume /= timeData.length;
        
        if (volume > 0.003) { // Soglia per presenza di discorso
            const pitch = detectPitch(timeData, audioContext.sampleRate);
            if (pitch && pitch > 50 && pitch < 500) {
                currentFrequency = pitch;
            }
        }
        console.log('Volume avg:', volume.toFixed(4), 'Max:', maxVol.toFixed(4), 'Pitch rilevato:', currentFrequency);
    }
    
    if (isFirstSpeech) {
        isFirstSpeech = false;
        if (currentFrequency !== null) {
            lastFrequencies.set(1, currentFrequency);
        }
        lastAssignedSpeaker = 1;
        lastSpeechTime = currentTime;
        return 1;
    }
    
    let assignedSpeaker;
    if (currentFrequency === null) {
        // Se non riusciamo a rilevare il pitch, manteniamo l'ultimo parlante assegnato
        assignedSpeaker = lastAssignedSpeaker;
    } else {
        // Trova il parlante con tonalit√† pi√π simile
        let bestSpeaker = null;
        let minDiff = Infinity;
        for (let [id, freq] of lastFrequencies) {
            if (freq !== null) {
                const diff = Math.abs(currentFrequency - freq);
                if (diff < minDiff) {
                    minDiff = diff;
                    bestSpeaker = id;
                }
            }
        }
        
        if (bestSpeaker !== null && minDiff < TONE_CHANGE_THRESHOLD) {
            // Stesso parlante
            assignedSpeaker = bestSpeaker;
            lastFrequencies.set(bestSpeaker, currentFrequency);
        } else {
            // Nuovo parlante
            let newId = 1;
            while (lastFrequencies.has(newId) && newId <= 5) newId++;
            if (newId > 5) {
                newId = 1;
            }
            assignedSpeaker = newId;
            lastFrequencies.set(newId, currentFrequency);
        }
    }
    
    lastAssignedSpeaker = assignedSpeaker;
    lastSpeechTime = currentTime;
    console.log('Parlante assegnato:', assignedSpeaker);
    return assignedSpeaker;
}

function createSpeakerSegment(text, speakerId, confidence) {
    const segment = document.createElement('div');
    segment.className = 'transcript-segment speaker-' + speakerId + '-segment';
    
    const header = document.createElement('div');
    header.className = 'segment-header';
    
    const speakerBadge = document.createElement('span');
    speakerBadge.className = 'speaker-' + speakerId;
    speakerBadge.textContent = speakerNames[speakerId] || 'Parlante ' + speakerId;
    
    header.appendChild(speakerBadge);
    
    const textDiv = document.createElement('div');
    textDiv.className = 'segment-text';
    textDiv.textContent = text;
    
    segment.appendChild(header);
    segment.appendChild(textDiv);
    
    return segment;
}

/* ===========================================
   REGISTRAZIONE VOCALE (Tempo Reale)
=========================================== */

recordBtn.addEventListener('click', () => {
    const mode = recordingMode.value;
    
    if (mode === 'realtime') {
        if (!recognition) {
            showStatus('‚ùå Riconoscimento vocale non supportato', 'error');
            return;
        }
        
        if (!isRecording) {
            startRecording(false);
        } else {
            stopRecording();
        }
    } else {
        // Record then transcribe mode
        if (!isRecording) {
            startAudioRecording();
        } else {
            stopAudioRecording();
        }
    }
});

recordingMode.addEventListener('change', () => {
    const apiKeyNoticeRec = document.getElementById('apiKeyNoticeRec');
    
    if (recordingMode.value === 'realtime') {
        recordBtnText.textContent = '‚ñ∂Ô∏è Inizia Registrazione';
        liveTranscript.style.display = 'block';
        recordedAudioSection.style.display = 'none';
        resumeBtn.style.display = transcript ? 'inline-flex' : 'none';
        if (apiKeyNoticeRec) apiKeyNoticeRec.style.display = 'none';
    } else {
        recordBtnText.textContent = '‚ñ∂Ô∏è Registra Audio';
        liveTranscript.classList.add('empty');
        liveTranscript.textContent = 'La registrazione verr√† trascritta dopo aver fermato.';
        resumeBtn.style.display = 'none';
        
        // Mostra avviso se non c'√® API key
        if (!groqApiKey.value.trim() && apiKeyNoticeRec) {
            apiKeyNoticeRec.style.display = 'block';
        } else if (apiKeyNoticeRec) {
            apiKeyNoticeRec.style.display = 'none';
        }
    }
});

resumeBtn.addEventListener('click', () => {
    if (!recognition) {
        showStatus('‚ùå Riconoscimento vocale non supportato', 'error');
        return;
    }
    startRecording(true);
});

async function startRecording(resume = false) {
    // Determina i parametri di qualit√†
    let sampleRate, audioBitsPerSecond;
    const qualityLevel = audioQuality.value;
    
    switch(qualityLevel) {
        case 'high':
            sampleRate = 48000;
            audioBitsPerSecond = 256000;
            break;
        case 'medium':
            sampleRate = 44100;
            audioBitsPerSecond = 192000;
            break;
        case 'low':
            sampleRate = 22050;
            audioBitsPerSecond = 128000;
            break;
        default:
            sampleRate = 44100;
            audioBitsPerSecond = 192000;
    }
    if (!resume) {
        transcript = "";
        liveTranscript.innerHTML = "";
        wordCount.textContent = "0 parole trascritte";
        resumeBtn.style.display = 'none';
        
        // Reset sistema parlanti
        speakers.clear();
        currentSpeaker = 1;
        lastSpeechTime = Date.now();
        isFirstSpeech = true;
        lastFrequencies.clear();
        lastAssignedSpeaker = 1;
        lastSegment = null;
        lastSegmentSpeaker = null;
        lastSegmentTime = 0;
    } else {
        // Riprendi dalla trascrizione precedente
        showStatus('‚Ü©Ô∏è Riprendendo la registrazione precedente...', 'info');
        
        // Ricarica e ricrea i segmenti dalla trascrizione precedente
        if (transcript) {
            const lines = transcript.trim().split('\n');
            for (const line of lines) {
                const match = line.match(/^\[Parlante (\d+)\]: (.+)$/);
                if (match) {
                    const speakerId = parseInt(match[1]);
                    const text = match[2];
                    const segment = createSpeakerSegment(text, speakerId, 0.85); // confidence dummy
                    liveTranscript.appendChild(segment);
                    lastSegment = segment;
                    lastSegmentSpeaker = speakerId;
                    lastSegmentTime = Date.now(); // dummy
                    // Update speakers map
                    if (!speakers.has(speakerId)) {
                        speakers.set(speakerId, { words: 0, segments: 0 });
                    }
                    const speakerData = speakers.get(speakerId);
                    speakerData.words += text.split(/\s+/).length;
                    speakerData.segments++;
                }
            }
            // Update counters
            const totalWords = transcript.split(/\s+/).filter(w => w.length > 0).length;
            wordCount.textContent = `${totalWords} ${totalWords === 1 ? 'parola trascritta' : 'parole trascritte'}`;
            const speakerNum = speakers.size;
            speakerCountDisplay.textContent = `${speakerNum} ${speakerNum === 1 ? 'parlante' : 'parlanti'}`;
        }
    }
    
    // Setup per analisi tono voce se necessario
    if (recordingStream && !analyser) {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 4096;
        const source = audioContext.createMediaStreamSource(recordingStream);
        source.connect(analyser);
        audioContext.resume(); // Riavvia AudioContext se sospeso
    }
    
    liveTranscript.classList.remove('empty');
    
    // Ottieni stream audio se necessario
    if (!recordingStream) {
        // Configurazione avanzata del microfono
        const audioConstraints = {
            audio: {
                echoCancellation: echoCancellation.checked,
                noiseSuppression: noiseSuppression.checked,
                autoGainControl: autoGainControl.checked,
                sampleRate: { ideal: sampleRate },
                sampleSize: { ideal: 16 },
                channelCount: { ideal: 2 },  // Stereo
            }
        };
        
        recordingStream = await navigator.mediaDevices.getUserMedia(audioConstraints);
        
        recordedChunks = [];
        
        // Prova a usare il miglior codec disponibile
        let mimeType;
        const possibleTypes = [
            'audio/webm;codecs=opus',  // Migliore qualit√† per voce
            'audio/webm',
            'audio/ogg;codecs=opus',
            'audio/mp4',
            ''  // Fallback al tipo predefinito
        ];
        
        for (const type of possibleTypes) {
            if (type === '' || MediaRecorder.isTypeSupported(type)) {
                mimeType = type;
                break;
            }
        }
        
        mediaRecorder = new MediaRecorder(recordingStream, { mimeType });
        
        mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
                recordedChunks.push(event.data);
            }
        };
        
        mediaRecorder.onstop = () => {
            const blob = new Blob(recordedChunks, { type: mimeType });
            recordedBlob = blob;
            downloadBtn.disabled = false;
        };
        
        mediaRecorder.start();
    }
    
    // Setup per analisi tono voce
    if (!analyser) {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 4096;
        const source = audioContext.createMediaStreamSource(recordingStream);
        source.connect(analyser);
        audioContext.resume(); // Riavvia AudioContext se sospeso
    }
    
    recognition.lang = languageSelect.value;
    recognition.interimResults = true;
    recognition.continuous = true;
    
    recognition.onresult = (event) => {
        let interimTranscript = "";
        
        for (let i = event.resultIndex; i < event.results.length; i++) {
            const result = event.results[i];
            const transcriptPiece = result[0].transcript;
            const confidence = result[0].confidence || 0.85;
            
            if (result.isFinal) {
                // Rileva quale parlante sta parlando
                const speakerId = detectSpeakerChange(transcriptPiece, confidence);
                
                // Se il transcript display √® vuoto o in modalit√† empty, puliscilo
                if (liveTranscript.classList.contains('empty') || liveTranscript.innerHTML === 'La trascrizione in tempo reale apparir√† qui...') {
                    liveTranscript.innerHTML = '';
                    liveTranscript.classList.remove('empty');
                }
                
                const now = Date.now();
                let segment;
                if (lastSegment && lastSegmentSpeaker === speakerId) {
                    // Aggiungi al segmento esistente
                    const textDiv = lastSegment.querySelector('.segment-text');
                    textDiv.textContent += ' ' + transcriptPiece;
                    segment = lastSegment;
                } else {
                    // Crea nuovo segmento
                    segment = createSpeakerSegment(transcriptPiece, speakerId, confidence);
                    liveTranscript.appendChild(segment);
                    lastSegment = segment;
                    lastSegmentSpeaker = speakerId;
                    lastSegmentTime = now;
                }
                
                // Aggiorna statistiche parlante (conteggio segmenti rimane per final results)
                if (!speakers.has(speakerId)) {
                    speakers.set(speakerId, {
                        words: 0,
                        segments: 0
                    });
                }
                const speakerData = speakers.get(speakerId);
                speakerData.words += transcriptPiece.split(/\s+/).length;
                speakerData.segments++;
                
                // Aggiorna transcript testuale
                const speakerLabel = speakerNames[speakerId] || 'Parlante ' + speakerId;
                transcript += `[${speakerLabel}]: ${transcriptPiece}\n`;
                
                // Salva immediatamente
                localStorage.setItem('transcript', transcript);
                
                // Aggiorna contatori
                const totalWords = transcript.split(/\\s+/).filter(w => w.length > 0).length;
                wordCount.textContent = `${totalWords} ${totalWords === 1 ? 'parola trascritta' : 'parole trascritte'}`;
                
                // Aggiorna contatore parlanti
                const speakerNum = speakers.size;
                speakerCountDisplay.textContent = `${speakerNum} ${speakerNum === 1 ? 'parlante' : 'parlanti'}`;
                
                // Auto-scroll verso il basso
                liveTranscript.scrollTop = liveTranscript.scrollHeight;
            } else {
                interimTranscript += transcriptPiece;
            }
        }
        
        // Mostra testo interim in grigio alla fine
        if (interimTranscript) {
            let tempDiv = document.getElementById('interimText');
            if (!tempDiv) {
                tempDiv = document.createElement('div');
                tempDiv.id = 'interimText';
                tempDiv.style.opacity = '0.6';
                tempDiv.style.fontStyle = 'italic';
                tempDiv.style.color = '#667eea';
                tempDiv.style.padding = '8px';
                liveTranscript.appendChild(tempDiv);
            }
            tempDiv.textContent = 'üé§ ' + interimTranscript;
            liveTranscript.scrollTop = liveTranscript.scrollHeight;
        } else {
            // Rimuovi div interim se non c'√® pi√π testo interim
            const tempDiv = document.getElementById('interimText');
            if (tempDiv) {
                tempDiv.remove();
            }
        }
    };
    
    recognition.onerror = (event) => {
        // Ignora errori di "no-speech" che sono normali durante pause
        if (event.error === 'no-speech') {
            return;
        }
        showStatus('‚ùå Errore: ' + event.error, 'error');
        if (event.error !== 'aborted') {
            stopRecording();
        }
    };
    
    recognition.onend = () => {
        // Riavvia automaticamente se sta ancora registrando
        if (isRecording) {
            try {
                recognition.start();
            } catch (err) {
                console.log('Tentativo di riavvio riconoscimento...');
                setTimeout(() => {
                    if (isRecording) {
                        recognition.start();
                    }
                }, 100);
            }
        }
    };
    
    try {
        recognition.start();
        isRecording = true;
        recordBtn.classList.add('recording');
        recordBtnText.textContent = '‚èπÔ∏è Ferma Registrazione';
        showStatus('üéôÔ∏è Registrazione in corso...', 'info');
    } catch (err) {
        showStatus('‚ùå Errore avvio registrazione', 'error');
    }
}

function stopRecording() {
    if (recognition) {
        recognition.stop();
    }
    
    isRecording = false;
    recordBtn.classList.remove('recording');
    recordBtnText.textContent = '‚ñ∂Ô∏è Inizia Registrazione';
    
    // Nascondi statistiche e ferma timer
    if (recordingInterval) {
        clearInterval(recordingInterval);
        recordingInterval = null;
    }
    setTimeout(() => {
        recordingStats.style.display = 'none';
    }, 2000);
    
    if (transcript.trim()) {
        // Mostra pulsante per riprendere
        resumeBtn.style.display = 'inline-flex';
        
        mainTranscript.innerHTML = liveTranscript.innerHTML;
        localStorage.setItem('transcript', liveTranscript.innerHTML);
        localStorage.setItem('transcriptText', transcript);
        enableAnalysisButtons();
        
        const wordsFinal = transcript.trim().split(/\s+/).length;
        const speakersDetected = speakers.size;
        showStatus(`‚úÖ Registrazione completata! ${wordsFinal} parole trascritte da ${speakersDetected} ${speakersDetected === 1 ? 'parlante' : 'parlanti'}.`, 'success');
        
        setTimeout(() => {
            tabs.forEach(t => t.classList.remove('active'));
            tabContents.forEach(tc => tc.classList.remove('active'));
            document.querySelector('[data-tab="analysis"]').classList.add('active');
            document.getElementById('tab-analysis').classList.add('active');
        }, 1000);
    }
}

/* ===========================================
   CARICA FILE AUDIO
=========================================== */

uploadArea.addEventListener('click', () => audioFileInput.click());

uploadArea.addEventListener('dragover', (e) => {
    e.preventDefault();
    uploadArea.classList.add('dragover');
});

uploadArea.addEventListener('dragleave', () => {
    uploadArea.classList.remove('dragover');
});

uploadArea.addEventListener('drop', (e) => {
    e.preventDefault();
    uploadArea.classList.remove('dragover');
    
    const file = e.dataTransfer.files[0];
    if (file && file.type.startsWith('audio/')) {
        handleAudioFile(file);
    } else {
        showStatus('‚ùå File non valido. Carica un file audio.', 'error');
    }
});

audioFileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) handleAudioFile(file);
});

function handleAudioFile(file) {
    audioFileName.style.display = 'block';
    audioFileName.textContent = `üìÅ ${file.name} (${(file.size/1048576).toFixed(2)} MB)`;
    
    const url = URL.createObjectURL(file);
    audioPlayer.src = url;
    audioPlayer.style.display = 'block';
    
    currentAudioFile = file;
    transcribeAudioBtn.disabled = false;
    transcriptionMethodSection.style.display = 'block';
    
    // Aggiorna il testo del pulsante in base al metodo
    updateTranscribeButtonText();
    
    showStatus('üìÅ File caricato. Scegli il metodo di trascrizione.', 'success');
}

function updateTranscribeButtonText() {
    if (transcriptionMethod.value === 'whisper') {
        transcribeAudioBtnText.textContent = 'ü§ñ Trascrivi con Whisper AI';
    } else {
        transcribeAudioBtnText.textContent = 'üé§ Trascrivi con Browser';
    }
}

transcriptionMethod.addEventListener('change', updateTranscribeButtonText);

transcribeAudioBtn.addEventListener('click', () => {
    if (transcriptionMethod.value === 'whisper') {
        transcribeWithWhisper();
    } else {
        transcribeAudioFile();
    }
});

async function transcribeWithWhisper() {
    const key = groqApiKey.value.trim();
    if (!key) {
        const whisperNotice = document.getElementById('whisperNotice');
        if (whisperNotice) whisperNotice.style.display = 'block';
        
        showStatus('‚ùå Inserisci la tua API Key Groq nella tab Analisi', 'error');
        // Scorri verso l'alto per vedere il notice
        window.scrollTo({ top: 0, behavior: 'smooth' });
        return;
    }

    // Nascondi notice se c'√® la chiave
    const whisperNotice = document.getElementById('whisperNotice');
    if (whisperNotice) whisperNotice.style.display = 'none';

    if (!currentAudioFile) {
        showStatus('‚ùå Nessun file caricato', 'error');
        return;
    }

    // Verifica dimensione file (max 25MB per Groq)
    if (currentAudioFile.size > 25 * 1024 * 1024) {
        showStatus('‚ùå File troppo grande (max 25MB). Usa un file pi√π piccolo o il metodo Browser.', 'error');
        return;
    }

    transcribeAudioBtn.disabled = true;
    transcriptionProgress.style.display = 'block';
    progressBar.style.width = '30%';
    progressText.textContent = 'Caricamento file...';

    try {
        // Prepara FormData
        const formData = new FormData();
        formData.append('file', currentAudioFile);
        formData.append('model', 'whisper-large-v3');
        formData.append('language', languageSelect.value.split('-')[0]); // 'it' da 'it-IT'
        formData.append('response_format', 'text');

        progressBar.style.width = '50%';
        progressText.textContent = 'Trascrizione in corso...';

        const response = await fetch('https://api.groq.com/openai/v1/audio/transcriptions', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${key}`
            },
            body: formData
        });

        progressBar.style.width = '90%';

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error?.message || `Errore API: ${response.status}`);
        }

        const transcriptText = await response.text();

        progressBar.style.width = '100%';
        progressText.textContent = 'Completato!';

        // Mostra risultato
        liveFileTranscript.style.display = 'block';
        liveFileTranscript.classList.remove('empty');
        liveFileTranscript.textContent = transcriptText;

        // Salva in mainTranscript
        mainTranscript.textContent = transcriptText;
        localStorage.setItem('transcript', transcriptText);
        enableAnalysisButtons();

        setTimeout(() => {
            transcriptionProgress.style.display = 'none';
            progressBar.style.width = '0%';
        }, 2000);

        const wordCount = transcriptText.trim().split(/\s+/).length;
        showStatus(`‚úÖ Trascrizione completata! ${wordCount} parole trascritte.`, 'success');

        // Passa alla tab analisi
        setTimeout(() => {
            tabs.forEach(t => t.classList.remove('active'));
            tabContents.forEach(tc => tc.classList.remove('active'));
            document.querySelector('[data-tab="analysis"]').classList.add('active');
            document.getElementById('tab-analysis').classList.add('active');
        }, 2000);

    } catch (error) {
        showStatus('‚ùå Errore trascrizione: ' + error.message, 'error');
        transcriptionProgress.style.display = 'none';
        progressBar.style.width = '0%';
    } finally {
        transcribeAudioBtn.disabled = false;
    }
}

function transcribeAudioFile() {
    if (!recognition) {
        showStatus('‚ùå Riconoscimento vocale non supportato', 'error');
        return;
    }
    
    fileTranscript = "";
    liveFileTranscript.style.display = 'block';
    liveFileTranscript.classList.remove('empty');
    liveFileTranscript.textContent = "Avvio riproduzione e trascrizione...";
    
    fileTranscriptionActive = true;
    
    // Avvia riproduzione audio
    audioPlayer.currentTime = 0;
    audioPlayer.play().then(() => {
        showStatus('‚ñ∂Ô∏è Riproduzione avviata. Trascrizione in corso...', 'info');
        
        recognition.lang = languageSelect.value;
        recognition.interimResults = true;
        recognition.continuous = true;
        
        recognition.onresult = (event) => {
            let interimTranscript = "";
            
            for (let i = event.resultIndex; i < event.results.length; i++) {
                const transcriptPiece = event.results[i][0].transcript;
                
                if (event.results[i].isFinal) {
                    fileTranscript += transcriptPiece + " ";
                    // Salva immediatamente
                    localStorage.setItem('fileTranscript', fileTranscript);
                } else {
                    interimTranscript += transcriptPiece;
                }
            }
            
            liveFileTranscript.innerHTML = 
                fileTranscript + 
                `<span style="color:#aaa;">${interimTranscript}</span>`;
            
            // Auto-scroll verso il basso
            liveFileTranscript.scrollTop = liveFileTranscript.scrollHeight;
        };
        
        recognition.onerror = (event) => {
            // Ignora errori di "no-speech" che sono normali durante pause
            if (event.error === 'no-speech') {
                return;
            }
            console.log('Errore riconoscimento:', event.error);
        };
        
        recognition.onend = () => {
            if (fileTranscriptionActive && !audioPlayer.paused && !audioPlayer.ended) {
                try {
                    recognition.start();
                } catch (err) {
                    console.log('Tentativo di riavvio riconoscimento...');
                    setTimeout(() => {
                        if (fileTranscriptionActive && !audioPlayer.paused && !audioPlayer.ended) {
                            recognition.start();
                        }
                    }, 100);
                }
            } else if (fileTranscriptionActive) {
                stopFileTranscription();
            }
        };
        
        // Avvia riconoscimento
        recognition.start();
        
    }).catch(err => {
        showStatus('‚ùå Errore avvio riproduzione', 'error');
        fileTranscriptionActive = false;
    });
    
    // Gestisci fine riproduzione
    audioPlayer.onended = () => {
        stopFileTranscription();
    };
}

stopTranscriptionBtn.addEventListener('click', stopFileTranscription);

function stopFileTranscription() {
    fileTranscriptionActive = false;
    
    if (recognition) recognition.stop();
    audioPlayer.pause();
    audioPlayer.currentTime = 0;
    
    transcribeAudioBtn.style.display = 'inline-flex';
    stopTranscriptionBtn.style.display = 'none';
    
    if (fileTranscript.trim()) {
        mainTranscript.textContent = fileTranscript;
        localStorage.setItem('transcript', fileTranscript);
        enableAnalysisButtons();
        showStatus('üìÑ Trascrizione completata!', 'success');
        
        setTimeout(() => {
            tabs.forEach(t => t.classList.remove('active'));
            tabContents.forEach(tc => tc.classList.remove('active'));
            document.querySelector('[data-tab="analysis"]').classList.add('active');
            document.getElementById('tab-analysis').classList.add('active');
        }, 800);
    }
}

/* ===========================================
   INCOLLA TESTO
=========================================== */

usePastedTextBtn.addEventListener('click', () => {
    const text = pastedText.value.trim();
    if (!text) {
        showStatus('‚ö†Ô∏è Incolla del testo prima', 'error');
        return;
    }
    
    mainTranscript.textContent = text;
    localStorage.setItem('transcript', text);
    enableAnalysisButtons();
    showStatus('üìÑ Testo caricato!', 'success');
    
    setTimeout(() => {
        tabs.forEach(t => t.classList.remove('active'));
        tabContents.forEach(tc => tc.classList.remove('active'));
        document.querySelector('[data-tab="analysis"]').classList.add('active');
        document.getElementById('tab-analysis').classList.add('active');
    }, 800);
});

/* ===========================================
   FUNZIONI ANALISI AI (GROQ)
=========================================== */

function enableAnalysisButtons() {
    correctTextBtn.disabled = false;
    summarizeBtn.disabled = false;
    analyzeBtn.disabled = false;
    identifySpeakersBtn.disabled = false;
    exportPdfBtn.disabled = false;
    exportTxtBtn.disabled = false;
    analysisInfo.style.display = 'none';
}

async function callGroqAPI(prompt) {
    const key = groqApiKey.value.trim();
    if (!key) {
        showStatus('‚ùå Inserisci la tua API Key Groq', 'error');
        return null;
    }
    
    localStorage.setItem('groqKey', key);
    
    showStatus('ü§ñ Analisi AI in corso...', 'loading');
    
    try {
        const res = await fetch('https://api.groq.com/openai/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${key}`,
            },
            body: JSON.stringify({
                model: 'llama-3.1-8b-instant',
                messages: [{ role: 'user', content: prompt }],
                temperature: 0.7,
                max_tokens: 4096,
            }),
        });
        
        if (!res.ok) {
            throw new Error(`Errore API: ${res.status}`);
        }
        
        const data = await res.json();
        return data.choices[0].message.content;
    } catch (err) {
        showStatus('‚ùå Errore Groq: ' + err.message, 'error');
        return null;
    }
}

/* ===== CORREZIONE TESTO ===== */
correctTextBtn.addEventListener('click', async () => {
    const text = mainTranscript.textContent.trim();
    if (!text) return;
    
    const prompt = `Correggi grammatica, punteggiatura e ortografia del seguente testo mantenendo il significato identico. Restituisci SOLO il testo corretto senza commenti:\n\n${text}`;
    
    const result = await callGroqAPI(prompt);
    if (!result) return;
    
    mainTranscript.textContent = result.trim();
    localStorage.setItem('transcript', result.trim());
    showStatus('‚ú® Testo corretto!', 'success');
});

/* ===== RIASSUNTO ===== */
summarizeBtn.addEventListener('click', async () => {
    const text = mainTranscript.textContent.trim();
    if (!text) return;
    
    const prompt = `Crea un riassunto strutturato del seguente testo in 5-7 punti chiave. Usa un formato chiaro con bullet points:\n\n${text}`;
    const result = await callGroqAPI(prompt);
    
    if (result) addAnalysisSection('üìù Riassunto', result);
});

/* ===== ANALISI COMPLETA ===== */
analyzeBtn.addEventListener('click', async () => {
    const text = mainTranscript.textContent.trim();
    if (!text) return;
    
    const prompt = `Analizza in modo approfondito il seguente testo. Includi:
1. Tema principale
2. Tono e stile
3. Punti chiave
4. Conclusioni o azioni da intraprendere

Testo:
${text}`;
    
    const result = await callGroqAPI(prompt);
    if (result) addAnalysisSection('üîç Analisi Completa', result);
});

/* ===== IDENTIFICAZIONE PARLANTI ===== */
identifySpeakersBtn.addEventListener('click', async () => {
    const text = mainTranscript.textContent.trim();
    if (!text) return;
    
    const prompt = `Analizza il seguente testo e identifica i possibili parlanti o interlocutori. Se sembrano esserci pi√π persone che parlano, suggerisci chi potrebbe dire cosa. Fornisci un'analisi chiara:\n\n${text}`;
    
    const result = await callGroqAPI(prompt);
    if (result) addAnalysisSection('üë• Identificazione Parlanti', result);
});

function addAnalysisSection(title, content) {
    const div = document.createElement('div');
    div.className = 'analysis-section';
    div.innerHTML = `<h3>${title}</h3><div class="analysis-content">${content.replace(/\n/g, '<br>')}</div>`;
    analysisResults.prepend(div);
    showStatus('‚ú® Analisi completata!', 'success');
}

/* ===========================================
   ESPORTAZIONE
=========================================== */

exportPdfBtn.addEventListener('click', () => {
    const text = mainTranscript.textContent.trim();
    if (!text) return;
    
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();
    
    const pageWidth = doc.internal.pageSize.getWidth();
    const margin = 15;
    const maxWidth = pageWidth - (margin * 2);
    
    doc.setFontSize(16);
    doc.text('Trascrizione Audio', margin, 20);
    
    doc.setFontSize(10);
    doc.text(`Data: ${new Date().toLocaleDateString('it-IT')}`, margin, 30);
    
    doc.setFontSize(12);
    const lines = doc.splitTextToSize(text, maxWidth);
    doc.text(lines, margin, 40);
    
    doc.save('trascrizione.pdf');
    showStatus('üìÑ PDF salvato!', 'success');
});

exportTxtBtn.addEventListener('click', () => {
    const text = mainTranscript.textContent.trim();
    if (!text) return;
    
    const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
    saveAs(blob, 'trascrizione.txt');
    showStatus('üìù TXT salvato!', 'success');
});

/* ===========================================
   CANCELLA TUTTO
=========================================== */

clearBtn.addEventListener('click', () => {
    if (!confirm('‚ö†Ô∏è Sei sicuro di voler cancellare tutto? Questa azione non pu√≤ essere annullata.')) {
        return;
    }
    
    localStorage.clear();
    mainTranscript.textContent = 'Nessuna trascrizione disponibile.';
    liveTranscript.textContent = 'La trascrizione in tempo reale apparir√† qui...';
    liveTranscript.classList.add('empty');
    liveFileTranscript.textContent = '';
    liveFileTranscript.style.display = 'none';
    pastedText.value = '';
    analysisResults.innerHTML = '';
    transcript = "";
    
    // Reset audio recordings
    recordedAudioSection.style.display = 'none';
    recordedBlob = null;
    recordedChunks = [];
    
    // Nascondi pulsante riprendi
    resumeBtn.style.display = 'none';
    
    correctTextBtn.disabled = true;
    summarizeBtn.disabled = true;
    analyzeBtn.disabled = true;
    identifySpeakersBtn.disabled = true;
    exportPdfBtn.disabled = true;
    exportTxtBtn.disabled = true;
    
    analysisInfo.style.display = 'block';
    
    showStatus('üóëÔ∏è Tutto cancellato!', 'info');
});

/* ===========================================
   GESTIONE DATI
=========================================== */

function clearAllData() {
    if (confirm('Sei sicuro di voler cancellare tutti i dati? Questa azione non pu√≤ essere annullata.')) {
        // Cancella localStorage
        localStorage.removeItem('transcript');
        localStorage.removeItem('transcriptText');
        localStorage.removeItem('groqKey');
        
        // Reset variabili
        transcript = "";
        speakers.clear();
        currentSpeaker = 1;
        
        // Reset UI
        mainTranscript.innerHTML = 'Nessuna trascrizione disponibile.';
        for (let i = 1; i <= 5; i++) {
            const input = document.getElementById('speaker' + i);
            if (input) input.value = '';
        }
        groqApiKey.value = '';
        
        // Salva nomi parlanti vuoti
        saveSpeakerNames();
        
        showStatus('‚úÖ Tutti i dati sono stati cancellati.', 'success');
    }
}

function saveSpeakerNames() {
    speakerNames = {};
    for (let i = 1; i <= 5; i++) {
        const input = document.getElementById('speaker' + i);
        if (input && input.value.trim()) {
            speakerNames[i] = input.value.trim();
        }
    }
    localStorage.setItem('speakerNames', JSON.stringify(speakerNames));
}

/* ===========================================
   FUNZIONE STATUS
=========================================== */

function showStatus(msg, type) {
    statusDiv.className = 'status active ' + type;
    statusDiv.innerHTML = 
        type === 'loading' 
        ? `<div class="spinner"></div><span>${msg}</span>`
        : msg;
    
    if (type !== 'loading') {
        setTimeout(() => statusDiv.classList.remove('active'), 4000);
    }
}

/* ===========================================
   SALVATAGGIO AUTOMATICO
=========================================== */

groqApiKey.addEventListener('input', () => {
    localStorage.setItem('groqKey', groqApiKey.value);
    
    // Nascondi notice se l'utente inserisce una chiave
    if (groqApiKey.value.trim()) {
        const apiKeyNotice = document.getElementById('apiKeyNotice');
        if (apiKeyNotice) apiKeyNotice.style.display = 'none';
        
        const apiKeyNoticeRec = document.getElementById('apiKeyNoticeRec');
        if (apiKeyNoticeRec) apiKeyNoticeRec.style.display = 'none';
    }
});

// Gestione sessioni salvate
function saveSession() {
    const name = sessionName.value.trim();
    if (!name) {
        showStatus('‚ùå Inserisci un nome per la sessione', 'error');
        return;
    }
    
    if (!transcript.trim() && !fileTranscript.trim()) {
        showStatus('‚ùå Nessuna trascrizione da salvare', 'error');
        return;
    }
    
    const session = {
        id: Date.now(),
        name: name,
        date: new Date().toLocaleString(),
        transcript: transcript || fileTranscript,
        transcriptHTML: mainTranscript.innerHTML,
        speakers: Array.from(speakers.entries()),
        wordCount: (transcript || fileTranscript).split(/\s+/).length
    };
    
    savedSessions.push(session);
    localStorage.setItem('savedSessions', JSON.stringify(savedSessions));
    
    sessionName.value = '';
    updateSessionsList();
    showStatus('‚úÖ Sessione salvata!', 'success');
}

function loadSession(sessionId) {
    const session = savedSessions.find(s => s.id === sessionId);
    if (!session) return;
    
    transcript = session.transcript;
    mainTranscript.innerHTML = session.transcriptHTML;
    speakers = new Map(session.speakers);
    
    // Aggiorna contatori
    const totalWords = transcript.split(/\s+/).length;
    wordCount.textContent = `${totalWords} ${totalWords === 1 ? 'parola trascritta' : 'parole trascritte'}`;
    const speakerNum = speakers.size;
    speakerCountDisplay.textContent = `${speakerNum} ${speakerNum === 1 ? 'parlante' : 'parlanti'}`;
    
    // Salva in localStorage
    localStorage.setItem('transcript', session.transcriptHTML);
    localStorage.setItem('transcriptText', session.transcript);
    
    enableAnalysisButtons();
    
    // Vai alla tab analisi
    tabs.forEach(t => t.classList.remove('active'));
    tabContents.forEach(tc => tc.classList.remove('active'));
    document.querySelector('[data-tab="analysis"]').classList.add('active');
    document.getElementById('tab-analysis').classList.add('active');
    
    showStatus(`üìÇ Sessione "${session.name}" caricata!`, 'success');
}

function deleteSession(sessionId) {
    if (!confirm('Sei sicuro di voler eliminare questa sessione?')) return;
    
    savedSessions = savedSessions.filter(s => s.id !== sessionId);
    localStorage.setItem('savedSessions', JSON.stringify(savedSessions));
    updateSessionsList();
    showStatus('üóëÔ∏è Sessione eliminata', 'info');
}

function updateSessionsList() {
    savedSessionsList.innerHTML = '';
    
    if (savedSessions.length === 0) {
        savedSessionsList.innerHTML = '<div style="text-align:center;color:#6b7280;padding:20px;" id="noSessionsMsg">Nessuna sessione salvata</div>';
        return;
    }
    
    savedSessions.forEach(session => {
        const sessionDiv = document.createElement('div');
        sessionDiv.style.cssText = 'border:1px solid #e5e7eb;border-radius:6px;padding:12px;margin-bottom:8px;background:white;';
        
        sessionDiv.innerHTML = `
            <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:8px;">
                <div>
                    <strong>${session.name}</strong>
                    <div style="font-size:12px;color:#6b7280;">${session.date} ‚Ä¢ ${session.wordCount} parole ‚Ä¢ ${session.speakers.length} parlanti</div>
                </div>
                <div>
                    <button onclick="loadSession(${session.id})" style="background:#10b981;color:white;border:none;padding:4px 8px;border-radius:4px;font-size:12px;margin-right:4px;">Carica</button>
                    <button onclick="deleteSession(${session.id})" style="background:#ef4444;color:white;border:none;padding:4px 8px;border-radius:4px;font-size:12px;">Elimina</button>
                </div>
            </div>
            <div style="font-size:14px;color:#374151;max-height:60px;overflow:hidden;">${session.transcript.substring(0, 150)}${session.transcript.length > 150 ? '...' : ''}</div>
        `;
        
        savedSessionsList.appendChild(sessionDiv);
    });
}

// Inizializza lista sessioni
updateSessionsList();

// Event listener per salvare sessione
saveSessionBtn.addEventListener('click', saveSession);

</script>

</script>

</body>
</html>
